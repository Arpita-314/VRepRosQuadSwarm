//	Copyright (c) 2014, Francesco Wanderlingh. 			        //
//	All rights reserved.						                //
//	License: BSD (http://opensource.org/licenses/BSD-3-Clause)  //

//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾//
// *Control of a Quadcopter simulated in VREP*	//
//______________________________________________//

#include "ros/ros.h"
#include "geometry_msgs/PoseStamped.h"
#include "std_msgs/Int64.h"
#include <cstring>
#include <sstream>
#include "termColors.h"
#include "PathPlanningAlg.h"
#include "robotInfo.h"
#include "quadcopterRosCtrl.h"
#include <fstream>
#include <unistd.h>
#include <vector>


using std::cout;
using std::endl;
using std::vector;

std_msgs::Int64 controlSignal;
geometry_msgs::PoseStamped quadPos;
int quadPosAcquired = 0;

std::string get_selfpath(void);
void loadPathFromFile(std::ifstream &file, vector< vector<float> > &robotPath);
void loadPath(vector< vector<float> > &robotPath, char * argvalue);
std::string add_argv(std::string str, char* argvalue);


void quadPosFromVrep(const geometry_msgs::PoseStamped::ConstPtr& pubQuadPose)
{
  quadPos.pose.position.x = pubQuadPose->pose.position.x;
  quadPos.pose.position.y = pubQuadPose->pose.position.y;
  quadPos.pose.position.z = pubQuadPose->pose.position.z;
  quadPosAcquired = 1;
}

void kernelCtrlSignal(const std_msgs::Int64::ConstPtr& control)
{
  controlSignal.data = control->data;
}

int main(int argc, char **argv)
{

  vector< vector<float> > robotPathVec;

  /* The following strings are used to concatenate the topic name to the argument passed to
   * the node (the argv[1]), so to name each node with a different name and send signals to
   *  different topics.
   * (e.g. if argv[1] = 0 the node will be named quadcopterRosCtrl_0, publish to
   *  vrep/targetObjPos_0, etc...)
   */
  std::string nodeName = add_argv("quadcopterRosCtrl", argv[1]);
  std::string targetObjPosName = add_argv("vrep/targetObjPos", argv[1]);
  std::string quadcopPosName = add_argv("vrep/quadcopPos", argv[1]);

  ros::init(argc, argv, nodeName);
  ros::NodeHandle n;

  ros::Publisher targetObjPos_pub = n.advertise<geometry_msgs::PoseStamped>(targetObjPosName, 100);
  ros::Subscriber quadcopPos_sub = n.subscribe(quadcopPosName, 100, quadPosFromVrep);
  ros::Subscriber ctrlSignal_sub = n.subscribe("quadCtrlSignal", 10, kernelCtrlSignal);

  ros::Rate loop_rate(DEF_LOOP_RATE); //Loop at DEF_LOOP_RATE


  float dist = 0;
  float treshold = 0.3;	// How much the quadcopter has to be near to the green sphere before the target moves
  float posZ  =  1.5;		// z for now is fixed!

  int wpIndex = 0;                                  // Waypoint index
  float wpArray[4][3] =  { { 0.0,  0.0,  4.0},      // Waypoint array
                            {-3.5,  0.0,  4.0},
                            {-3.5,  3.5,  4.0},
                            {-3.5,  3.5,  8.0}  };
  float subDist = 0;
  int inSubPath = 0;

  geometry_msgs::PoseStamped targetPos;
  geometry_msgs::PoseStamped subTarget;

  //  started == 2 means that this is the first iteration of the node (used for alert msg purposes)
  int started = 2;

  targetPos.pose.position.x = wpArray[wpIndex][X];
  targetPos.pose.position.y = wpArray[wpIndex][Y];
  targetPos.pose.position.z = wpArray[wpIndex][Z];
//  targetObjPos_pub.publish(targetPos);	//Initializing target (publishing its position to vrep)


  /*		*** PoseStamped structure: ***
  //		std_msgs/Header header
  //		  uint32 seq
  //		  time stamp
  //		  string frame_id
  //		geometry_msgs/Pose pose
  //		  geometry_msgs/Point position
  //			float64 x
  //			float64 y
  //			float64 z
  //		  geometry_msgs/Quaternion orientation
  //			float64 x
  //			float64 y
  //			float64 z
  //			float64 w
  */

  cout << "[" << argv[1] << "] Waiting for start....    " << endl;

  controlSignal.data = 0;
  int loaded = 0;

  while (ros::ok())
  {
    if( controlSignal.data != 0){
      if (loaded == 0){
        loadPath(robotPathVec, argv[1]);
        loaded = 1;
      }

      if(quadPosAcquired){

        quadPosAcquired = 0;

        // Calculating current l^2-norm between target and quadcopter (Euclidean distance)
        dist = PathPlanningAlg::Distance(&quadPos, &targetPos);
        // std::cout << "Distance to target = " << dist << " m" << std::endl;
        if(inSubPath == 0){
          if( abs(dist) > CRITICAL_DIST ){
            inSubPath = 1;
            float dSubWP[3];
            PathPlanningAlg::InterpNewPoint(&quadPos, &targetPos, dSubWP);
            subTarget.pose.position.x = quadPos.pose.position.x + dSubWP[X];
            subTarget.pose.position.y = quadPos.pose.position.y + dSubWP[Y];
            subTarget.pose.position.z = quadPos.pose.position.z + dSubWP[Z];
            targetObjPos_pub.publish(subTarget);            // PUBLISH NEW SUBTARGET POSITION
            //std::cout << "First subTarget Published!" << std::endl;

          }else if(abs(dist) < treshold){

            targetPos.pose.position.x = wpArray[wpIndex][X];
            targetPos.pose.position.y = wpArray[wpIndex][Y];
            targetPos.pose.position.z = wpArray[wpIndex][Z];

            if( abs(PathPlanningAlg::Distance(&quadPos, &targetPos)) < treshold){
              targetObjPos_pub.publish(targetPos);            // PUBLISH NEW TARGET POSITION
              //std::cout << "Target #" << wpIndex << " reached!" << std::endl;
              //std::cout << "Target Published!" << std::endl;
            }
            wpIndex++;
            if(wpIndex == 4) wpIndex = 0;
          }
        }else if( abs((PathPlanningAlg::Distance(&quadPos, &subTarget)) < treshold) ){
          float dSubWP[3];
          PathPlanningAlg::InterpNewPoint(&quadPos, &targetPos, dSubWP);
          subTarget.pose.position.x = quadPos.pose.position.x + dSubWP[X];
          subTarget.pose.position.y = quadPos.pose.position.y + dSubWP[Y];
          subTarget.pose.position.z = quadPos.pose.position.z + dSubWP[Z];
          targetObjPos_pub.publish(subTarget);            // PUBLISH NEW SUBTARGET POSITION
          //std::cout << "subTarget Published!" << std::endl;
          if (abs(dist) < treshold){
            inSubPath = 0;
          }
        }


      }else{              /// THIS PART IS EXECUTED IF VREP IS NOT RUNNING

        if (started == 1 || started == 2) {
          printf("%s** No incoming vrep/quadcopter position! (waiting...) **%s\n", TC_YELLOW, TC_NONE);
        }
        started = 0;              //
      }
    }

    ros::spinOnce();
    loop_rate.sleep();
  }

  return 0;
}


void loadPathFromFile(std::ifstream &file, vector< vector<float> > &robotPath){

  robotPath.push_back( vector<float>() );

  int pathVecIndex = 0;
  if( file.is_open() ) {
    float val;
    while( file >> val ){
      robotPath[pathVecIndex].push_back( val );

      if(file.peek() == '\n'){
        robotPath.push_back( vector<float>() );
        ++pathVecIndex;
      }
    }
    file.close();
  }else{
    cout << "Error reading file!" << endl;
  }

  /*
  std::cout << "The contents of Path are:" << endl;
  for (std::vector< vector<float> >::iterator itr = robotPath.begin(); itr != robotPath.end(); ++itr){
    for (std::vector<float>::iterator itc = itr->begin(); itc != itr->end(); ++itc){
        std::cout << *itc << ' ';
    }
    std::cout << '\n';
  }
*/

}


void loadPath(vector< vector<float> > &robotPath, char * argvalue){

    std::ifstream robotPathFile;
    std::string filename = "path";

    std::string folder_path = get_selfpath();
    std::string file_path = folder_path + "/" + add_argv(filename, argvalue);

    robotPathFile.open( file_path.c_str() );


    loadPathFromFile(robotPathFile, robotPath);
/*
    std::cout << "The contents of Path are:" << endl;
    for (std::vector< vector<float> >::iterator itr = robotPath.begin(); itr != robotPath.end(); ++itr){
      for (std::vector<float>::iterator itc = itr->begin(); itc != itr->end(); ++itc){
          std::cout << *itc << ' ';
      }
      std::cout << '\n';
    }
    */
}


std::string get_selfpath() {
    char buff[2048];
    ssize_t len = ::readlink("/proc/self/exe", buff, sizeof(buff)-1);
    if (len != -1) {
      buff[len] = '\0';
      std::string path(buff);   ///Here the executable name is still in
      std::string::size_type t = path.find_last_of("/");   // Here we find the last "/"
      path = path.substr(0,t);                             // and remove the rest (exe name)
      return path;
    } else {
     printf("Cannot determine file path!\n");
    }
}


std::string add_argv(std::string str, char* argvalue){

  std::string suffix(argvalue);
  str = str + "_" + suffix;

  return str;

}
